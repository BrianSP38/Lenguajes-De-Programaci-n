Codigo:

/* simplest version of calculator */
%{
#include <stdio.h>
%}
/* declare tokens */
%token NUMBER
%token ADD SUB MUL DIV ABS
%token EOL
%%
calclist: /* nothing */ matches at beginning of input
 | calclist exp EOL { printf("= %d\n", $1); } EOL is end of an expression
 ;
exp: factor default $$ = $1
 | exp ADD factor { $$ = $1 + $3; }
 | exp SUB factor { $$ = $1 - $3; }
 ;
factor: term default $$ = $1
 | factor MUL term { $$ = $1 * $3; }
 | factor DIV term { $$ = $1 / $3; }
 ;
term: NUMBER default $$ = $1
 | ABS term { $$ = $2 >= 0? $2 : - $2; }
;
%%
main(int argc, char **argv)
{
 yyparse();
}
yyerror(char *s)
{
 fprintf(stderr, "error: %s\n", s);
}

Pregunta: ¿Puedes pensar en idiomas para los que Flex no sería una buena herramienta para escribir un escáner?

Flex no resulta adecuado para ciertos tipos de lenguajes, en especial aquellos que dependen de conteo y balanceo de símbolos.

Rasgos de este tipo de lenguajes:
-Requieren llevar un registro de cuántas veces aparece un símbolo en particular.
-Exigen que todo símbolo de apertura tenga un cierre correspondiente.
-Su estructura depende de relaciones entre tokens que pueden estar separados en la entrada.

Limitaciones de Flex frente a ellos:
-Al estar fundamentado en expresiones regulares, solo es capaz de procesar lenguajes regulares.
-Los lenguajes de conteo y balance pertenecen a la categoría de libres de contexto, los cuales necesitan memoria
y la capacidad de generar secuencias más complejas mediante no terminales, algo que Flex no puede manejar.
